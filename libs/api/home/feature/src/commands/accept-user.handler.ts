
import { CommandHandler, EventPublisher, ICommandHandler } from '@nestjs/cqrs';
import { AcceptUserCommand, IAcceptUserResponse, IParsingData, IUserMatch, IUserRef } from '@mp/api/home/util';
import { Home } from '../models';
import { HomeRepository } from '@mp/api/home/data-access';
import { ChatRepository } from '@mp/api/chat/data-access';
import { ChatListRepository } from '@mp/api/chat-list/data-access';
import {IChat} from '@mp/api/chat/util'
import { UserProfileRepository } from '@mp/api/users/data-access';
import { NotificationRepository } from '@mp/api/notifications/data-access';
import { IInbox } from '@mp/api/notifications/util';
import { Timestamp } from 'firebase-admin/firestore';
@CommandHandler(AcceptUserCommand)
export class AcceptUserHandler
  implements ICommandHandler<AcceptUserCommand, IAcceptUserResponse>
{
  constructor(
      private publisher: EventPublisher, 
      private readonly repository: HomeRepository, 
      private readonly chatRepo: ChatRepository, 
      private readonly chatList: ChatListRepository,
      private readonly userProfileRepository: UserProfileRepository,
      private readonly notifRepository:NotificationRepository
    ) {}

  async execute(command: AcceptUserCommand) {
    console.log(`${AcceptUserHandler.name}`);

    const request = command.request;
    const userId = request.userId;
    // get home data of current user
    const resp = await this.repository.getHomeValuesForUser(userId) as IUserRef;
    // get user profile of accepted user
    const swipedUser = (await this.userProfileRepository.getUserProfile(request.swipedUserId))?.data();
    if (swipedUser == null || swipedUser == undefined) throw new Error('User not found');
    // created IUserMatch object for accepted user
    const userMatch: IUserMatch = {user:swipedUser, match: resp.accepted.includes(swipedUser.userId)};
    // check that it exists because vscode complains >:(
    if(!userMatch.user?.userId) throw new Error('User ID is null');
    // create home object
    const data: IParsingData = {userId:userId, userRef:resp};
    const home = this.publisher.mergeObjectContext(Home.fromData(data));

    // if users accepted each other, create chat object
    if (userMatch.match){
      const data: IChat = {
        chatId: "",
        messages: [],
        timeAdderId: userMatch.user.userId,
        timeRemaining: 1800,
        totalTimeUsed: 0,
        users: [userId, userMatch.user.userId],
      }
      // create chat object in firestore
      const now: any = Timestamp.fromDate(new Date());
      const chatResp = (await this.chatRepo.createChat(data));
      const notifData1: IInbox={
        content:"You have a new match!",
        recipient:userMatch.user.userId,
        sender:userId,
        time: now
      };
      const notifData2: IInbox={
        content:"You have a new match!",
        recipient:userId,
        sender:userMatch.user.userId,
        time: now
      };
      const notifResp = (await this.notifRepository.sendNotification(userId,notifData1));
      const notifResp2 = (await this.notifRepository.sendNotification(userMatch.user.userId,notifData2));
      // check that chat was created
      if(!chatResp) throw new Error('Chat not created');
      // update chat object with chatID generated by firestore
      data.chatId = chatResp.chatId;
      // add chat references to both users' chat lists
      this.chatList.addToChatList(userId,data.chatId,swipedUser.userId);
      this.chatList.addToChatList(swipedUser.userId,data.chatId,userId);
    }

    // accept user
    home.acceptUser(userMatch);
    home.commit();

    // return home object
    const response: IAcceptUserResponse ={home:home} as IAcceptUserResponse;
    return response;
  }
}
